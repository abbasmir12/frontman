import { IApiDefinition, IMethodDefinition } from '../types'; // Ensure IApiDefinition is imported
import { SchemaParser } from '../api/parsers/SchemaParser';

export class CodeGenerator {
    constructor(private schemaParser: SchemaParser) {}

    /**
     * Generates a code stub for the given method and language.
     * @returns The generated code string.
     */
    public async generateCode(methodId: string, language: string): Promise<string> {
        const method = this.schemaParser.getMethodById(methodId);
        if (!method) {
            throw new Error(`Method with ID ${methodId} not found.`);
        }

        const api = this.schemaParser.getApiById(method.parentApiId!);
        if (!api) {
            throw new Error(`API definition not found for method ${method.name}`);
        }

        console.log(`Generating code for method: ${method.name} in language: ${language}`);

        // --- Language/Protocol Specific Generation ---
        let code = '';

        if (api.type === 'openapi') {
             if (language === 'typescript-axios') {
                code = this.generateAxiosCode(api, method); // CORRECTED: Use this.
             } else if (language === 'javascript-fetch') {
                 code = this.generateFetchCode(api, method); // CORRECTED: Use this.
             } else {
                 code = `// Code generation for ${language} is not supported for OpenAPI\n`;
             }
        } else if (api.type === 'grpc') {
             if (language === 'typescript-grpc') {
                 code = this.generateGrpcNodeCode(api, method); // CORRECTED: Use this.
             } else {
                 code = `// Code generation for ${language} is not supported for gRPC\n`;
             }
        } else if (api.type === 'graphql') {
             if (language === 'typescript-graphql-request') {
                 // CORRECTED: Use this.
                 code = this.generateGraphqlRequestCode(api, method);
             } else {
                 code = `// Code generation for ${language} is not supported for GraphQL\n`;
             }
        } else {
             code = `// Code generation not supported for API type: ${api.type}\n`;
        }

        // Add a header indicating generated code
        return `// Auto-generated by Universal API Navigator\n// Method: ${method.name} (${api.type})\n\n${code}`;
    }

    private generateAxiosCode(api: any, method: IMethodDefinition): string {
        // Simple Axios example
        const baseUrl = api.servers?.[0]?.url || 'YOUR_BASE_URL';
        let url = method.protocolDetails.path;
        // TODO: Add path parameter substitution placeholders
        // TODO: Generate example request body based on schema
        // TODO: Generate example query parameters based on schema

        // Find a parameter that represents the request body (basic heuristic)
         const bodyParam = method.parameters.find(p => p.schema && (p.schema.in === 'body' || p.schema.in === undefined));
         const bodyExample = bodyParam ?
            "// TODO: Generate example body based on schema\nconst requestBody = {};\n" : '';

        return `import axios from 'axios';

const baseUrl = '${baseUrl}';
const url = \`\${baseUrl}${url}\`; // TODO: Add path parameter substitution

${bodyExample}
const headers = {
    // TODO: Add example headers like Authorization, Content-Type
    // 'Content-Type': 'application/json'${bodyParam ? ',\n    // Accept: \'application/json\' // Often recommended for JSON APIs' : ''}
};

axios({
    method: '${method.protocolDetails.httpMethod}',
    url: url,
    headers: headers,
    ${bodyParam ? 'data: requestBody,\n' : ''} // Use data for body with axios
    // TODO: Add params: {} for query parameters
})
.then(response => {
    console.log('Status:', response.status);
    console.log('Headers:', response.headers);
    console.log('Data:', response.data);
})
.catch(error => {
    console.error('Error:', error.response?.status || error.message);
    console.error('Error Data:', error.response?.data);
});
`;
    }

    private generateFetchCode(api: any, method: IMethodDefinition): string {
         // Simple Fetch example - similar logic to Axios
         const baseUrl = api.servers?.[0]?.url || 'YOUR_BASE_URL';
          let url = method.protocolDetails.path;
           const bodyParam = method.parameters.find(p => p.schema && (p.schema.in === 'body' || p.schema.in === undefined));
           const bodyExample = bodyParam ? "// TODO: Generate example body based on schema\nconst requestBody = {};\n" : '';


         return `const baseUrl = '${baseUrl}';
const url = \`\${baseUrl}${url}\`; // TODO: Add path parameter substitution
// TODO: Add query parameters to the URL string

${bodyExample}
const headers = {
    // TODO: Add example headers
    // 'Content-Type': 'application/json'${bodyParam ? ',\n    // Accept: \'application/json\' // Often recommended for JSON APIs' : ''}
};

fetch(url, {
    method: '${method.protocolDetails.httpMethod}',
    headers: headers,
    ${bodyParam ? 'body: JSON.stringify(requestBody),\n' : ''} // Use body for fetch
})
.then(response => {
    console.log('Status:', response.status);
    console.log('Headers:', response.headers); // Note: Fetch headers are less convenient
    if (!response.ok) {
        throw new Error(\`HTTP error! status: \${response.status}\`);
    }
    return response.json(); // Or response.text() based on content type
})
.then(data => {
    console.log('Data:', data);
})
.catch(error => {
    console.error('Error:', error);
});
`;
     }

    private generateGrpcNodeCode(api: any, method: IMethodDefinition): string {
         // Basic gRPC Node.js example - requires proto file loading and client setup
         // This is quite involved and would require specific code to map method details
         // to the generated client methods.

         // CORRECTED: Removed problematic commented block
         return `// gRPC client code generation requires analyzing the .proto structure
// and using @grpc/proto-loader to generate client methods dynamically
// or using grpc-tools to pre-generate static client stubs.

// This is a complex feature requiring detailed proto parsing and code generation logic.
// Placeholder for gRPC code generation for method: ${method.name}
// from proto file: ${api.id}
// Method parent service ID (for lookup): ${method.parentServiceId}
// Required libraries: @grpc/grpc-js, @grpc/proto-loader, protobufjs (often peer dep)

/*
// Example (simplified - requires actual proto file and generated client):
const PROTO_PATH = './path/to/your.proto'; // TODO: Get actual proto path from API definition
const grpc = require('@grpc/grpc-js');
const protoLoader = require('@grpc/proto-loader');

const packageDefinition = protoLoader.loadSync(
    PROTO_PATH,
    {keepCase: true,
     longs: String,
     enums: String,
     defaults: true,
     oneofs: true
    });
// Assuming your package is 'my.package' and service is 'MyService'
const protoDescriptor = grpc.loadPackageDefinition(packageDefinition);
const protoPackage = protoDescriptor; // TODO: Navigate this based on your proto structure and package name
const ServiceClient = protoPackage.${method.parentServiceId.split('-').pop()}; // TODO: Get service name correctly

// TODO: Get address from config or user input
const client = new ServiceClient('localhost:50051', grpc.credentials.createInsecure());

const request = {
    // TODO: Build request object based on method.parameters and payload data
};

client.${method.name}(request, (err, response) => { // This is for unary/server-streaming. Client/Bi-directional streaming is different.
    if (err) {
        console.error('gRPC Error:', err);
    } else {
        console.log('gRPC Response:', response);
    }
});
*/
`;
    }

    private generateGraphqlRequestCode(api: any, method: IMethodDefinition): string {
         // Simple graphql-request example
         const endpoint = 'YOUR_GRAPHQL_ENDPOINT'; // TODO: Get endpoint from config/schema/api details

         // TODO: Generate the query string based on the method (query/mutation/subscription)
         // and its parameters/response fields. This is complex and likely needs traversing the ITypeDefinition.
         // This needs to be a STRING that represents the query.
         const queryString = `// TODO: Generate GraphQL Query/Mutation/Subscription string for ${method.name}
// Based on schema: ${api.id}
// Parameters: ${method.parameters.map(p => p.name).join(', ')}
// Response: ${method.response ? (typeof method.response === 'string' ? method.response : method.response.name || method.response.type) : 'void'}
/*
// Example:
mutation CreateUser($input: CreateUserInput!) {
  createUser(input: $input) {
    id
    name
    email
  }
}
*/
`; // This is a string variable holding the template

         // TODO: Generate example variables based on parameter schema
         // This needs to be a STRING that represents the JS object
         const variablesExample = `// TODO: Generate example variables object for ${method.name}
const variables = {
    // input: { name: "test", email: "test@example.com" }
};
`; // This is a string variable holding the template

        // CORRECTED: Interpolate the STRING variables into the final generated code STRING template
        return `import { GraphQLClient, gql } from 'graphql-request';

const endpoint = '${endpoint}';

${queryString}
const query = gql\`
// PASTE GENERATED GRAPHQL QUERY/MUTATION/SUBSCRIPTION STRING HERE
// Based on method: ${method.name}
\`;

${variablesExample}

const headers = {
    // TODO: Add example headers like Authorization
};

const client = new GraphQLClient(endpoint, { headers });

client.request(query, variables)
  .then(data => {
    console.log('GraphQL Data:', data);
  })
  .catch(error => {
    console.error('GraphQL Error:', error);
    console.error('GraphQL Error Details:', error.response?.errors || error.message);
    console.error('GraphQL Error Data:', error.response?.data);
  });
`; // Keep the outer backticks for the final generated code string
    }

    // TODO: Add methods for other languages/libraries
}